---
title: <center> <h1> R 기초 및 데이터 다루기 </h1> </center>
date : <center> 2018.03.14.(Wed) </center>
output:
  html_document:
    toc: yes
    toc_depth: '2'
header-includes:
- \usepackage{booktabs}
- \usepackage{sectsty} \sectionfont{\centering \emph}
---


### 실습목표
> 1. R의 기초 문법 실습
> 2. 패키지 설치 및 라이브러리 불러오는 방법 이해
> 3. 실제 데이터를 활용해 주요 패키지 실습


```{r "setup", include = FALSE}
knitr::opts_knit$set(root.dir = "C:/BusinessAnalytics/data")
```

# 1. 실습환경 구축하기

실습에 필요한 Data는 패키지에 내장된 data를 불러오거나 사전에 제공한 data를 기반으로 한다.
데이터를 불러오는 코드를 실행하기 위해 본 강좌에서는 실습 data가 저장된 디렉토리를 통일하도록 한다.

통일할 디렉토리는 다음과 같다. 
```
C:/BusinessAnalytics/data
```
※ 참고로 R에서 디렉토리를 지정할때는 반드시 디렉토리를 복사해온 후 `\`를 `/`로 바꿔주어야 한다


# 2. 기초문법

## 2-1. 값(Value) 또는 벡터(Vector) 정의하기

가장 기본이 되는 값(Value)을 정의(선언)해보자. 항상 정의를 받는 `변수`가 먼저 나온다.
```{r}
a <- 3
```

변수는 문자형으로 정의할 수도 있다. R에서 문자형을 입력할땐 반드시 `" "` 안에 문자를 넣어준다.
```{r}
b <- "hello"
```

마찬가지로 벡터(vector)를 정의할 수 있다. 벡터를 정의할땐 주로 `c()`를 쓴다.
```{r}
c <- c(1,2,3,4,5)
d <- c(11,12,13,14,15)
```

문자로 이루어진 벡터(Vector)도 만들 수 있다.
```{r}
e <- c("apple", "banana", "orange")
```

## 2-2. 변수(Variable) 타입 및 데이터(Data) 타입 보기

R에서 주로 마주하는 변수타입은 5개이다. 변수 및 데이터 타입을 보는 방법은 `class()` 이다.

위에서 정의한 값들이 어떤 변수 타입인지 살펴보자.

```{r}
class(a)
class(b)
class(c)
class(d)
class(e)
```

두 개 이상의 벡터(vector)를 합치면 매트릭스(matrix)가 된다고 했다.
위에서 `c`와 `d`가 현재 벡터(Vector)로 이루어져 있는데, 이 둘을 합쳐 매트릭스(matrix)를 만들어 보자.

현재 `c`와 `d` 벡터 모두 행 벡터인지, 열 벡터인지 정해지지 않았는데, 두 벡터를 합칠때 
자동으로 행벡터 혹은 열벡터로 포함된다.

벡터를 행 단위로 합칠때는 `rbind`를 쓰고, 열 단위로 합칠때는 `cbind`를 쓴다.

먼저 행 단위로 합쳐보자.
```{r}
mat_a <- rbind(c, d)
```

이제 `mat_a`가 어떤 타입인지 살펴보면 2 X 5 매트릭스가 되어있다.
```{r}
mat_a
class(mat_a)
```

다음은 `cbind`를 써보자. `cbind`를 쓰면, 5 X 2 매트릭스가 된 것을 알 수 있다.
```{r}
mat_b <- cbind(c, d)
mat_b
class(mat_b)
```


## 2-3. 데이터(Data) 생성하기

데이터는 기본적으로 값 또는 벡터들로 구성이 된다.
경우에 따라 R에서 직접 Data를 생성하기도 하고, 기 생성된 data를 불러오기도 한다.

생성된 data를 불러와서 분석하는 것이 대부분이며, 이는 뒤에서 다루도록 하고
먼저 직접 데이터를 생성해보도록 하자.

R에서 데이터 타입은 총 5가지(Vector, Matrix, Data Frame, List, Array)이나 `Array`는 따로
다루지 않도록 한다. 

### Vector 생성하기

R에서는 Vector를 `데이터`가 아니라 `value`로 간주하나 `vector`를 데이터로 간주하도록 변경할 수도 있다.

x와 y라는 vector를 하나 생성해보자.
```{r}
x <- c(1,3,5,7,9)
y <- c("국어", "영어", "수학")
```
x와 y 모두 value로 간주되어 `class`를 살펴봐도 변수 타입 중 하나로 정의되어 있다.
```{r}
class(x)
class(y)
```

만약, Vector를 data frame 으로 정의하고 싶으면 `as.data.frame()`이라는 함수를 쓰면 된다.
```{r}
x <- as.data.frame(x)
class(x)
```
또한, vector를 matrix로 정의하고 싶으면, `as.matrix()` 라는 함수를 쓰면 된다.
```{r}
y <- as.matrix(y)
class(y)
```

### matrix 생성하기기

matrix는 위와 같이 vector를 붙여서 만들 수 도 있지만, 자체적으로 생성가능한 `matrix()`라는
함수도 존재한다.

```{r}
mat <- matrix(data = 1:9, ncol = 3)
```

```{r}
mat <- matrix(data = 1:9, nrow = 3) 
```

```{r}
mat <- matrix(data = 1:9, nrow = 3, byrow = TRUE)
```


### data frame 생성하기

매트릭스(matrix)와 데이터프레임(data frame)의 가장 큰 차이는 매트릭스(matrix)는 수학적인 관점에서 정의된 형태에고, 데이터프레임(data frame)은 프로그래밍의 관점에서 정의된 형태이다.

데이터프레임은(data frame)은 행과 열을 지니고 있으면서, 각 열은 변수명을 지니고 있는 형태이다.

```{r}
grade <- data.frame(name = c("국어", "영어", "수학"), 
                    score = c(90, 80, 88),
                    grade = c("A0", "B-", "A0"))

```

### List 생성하기

```{r}
grade <- list(name = c("국어", "영어", "수학"), 
              score = c(90, 80, 88),
              grade = c("A0", "B-", "A0"))
```

list 안에 속한 데이터를 보는 방법은 다음과 같다.
```{r}
grade[1]
```

```{r}
grade[[1]]
```


## 2-4. 연산자(Operator) 연산

R에서 사칙연산은 매우 간단하다.

### 덧셈 및 뺄셈
```{r}
1+3
```

```{r}
x <- 3
y <- 4
```

```{r}
x+y
```

```{r}
3-5
```

```{r}
y-x
```

### 곱셈
```{r}
a <- 3
b <- 4
```

```{r}
a*b
```
### 나눗셈
```{r}
4/5
```

```{r}
a/b
```

### sequence 만들기

수열(sequence)을 만드는 여러 방법이 있으나 `seq`와 `rep`을 가장 많이 쓴다.
```{r}
# 1부터 100까지 3씩 커지는 수열
seq(1, 100, by=3)
```
```{r}
# 1부터 10까지의 인덱스 벡터 만들기
index <- seq(1, 10, by=1)
```

```{r}
# 2010부터 2018까지 2번 반복
rep(2010:2018, 2)
```

```{r}
# 사과와 오렌지를 각각 3번씩 반복
rep(c("사과", "오렌지"), each=3)
```



## 2-5. If 문 만들기; 통제문(Control statement)

통제문은 자료처리 단계에서 가장 많이 쓰이는 유형 중 하나로 통제문을 잘 쓰면
자료처리의 능률이 매우 높아질 수 있다.

```{r}
x <- 3
x %% 2
```

```{r}
# %% 는 나눠서 나머지를 구하는 연산자
if(x %% 2 == 1){
    print("홀수")
} else{
    print("짝수")
}
```

ifelse(내가 원하는 조건, 그 조건충 ㅊ족했을때 값, 그렇지 않을때의 값)
```{r}
ifelse(x %%2 <= 0, "참", "거짓") 
```

## 2-6. For 문 만들기; 반복문(loop statement)

프로그래밍 언어의 가장 강력한 무기 중 하나가 반복문이며, 반복되는 작업이나 연산을 
for문으로 반복문을 구성하면 매우 편해진다. 

데이터의 양이 많아지면서 계산이 복잡해지고, 반복되는 작업이 많은 요즘
for문을 잘 활용하면 매우 편리하다.

```{r}
hi <- "hi"
```

```{r}
hi <- "hi"
print(hi)
cat(hi)
```
```{r}
year <- 2010:2018
year
```

```{r}
for(i in 2001:2010){
  cat("올해는", i, "년 입니다. \n") 
}

```

```{r}
for(i in year){
    print(paste("올해는", i, "입니다.")) 
}
```

```{r}
for(i in year){
    message("This is", " ", i, ".")
}
```

### If 문과 For 문의 결합

다음은 `if문`과 `for문`을 결합한 예시이다.
8명의 지원자가 있는데, `1`을 받으면 `합격`, `0`을 받으면 `불합격`이 
뜨도록 해보자.

```{r}
idx <- c(1,0,0,0,1,1,1,0)
idx[4]

for(i in 1:8){
  if(idx[i]==1){
    print("당신은 합격입니다")
  } else{
    print("당신은 불합격입니다")
  }
}

```


# 실습 : for문과 if문을 이용해 구구단 만들기
```{r}
for(i in 2:9){
    for(j in 1:10)
        cat(i, "*", j, "=", i * j, "\t", 
            if(j==5) paste("\n"), 
            if(j==10) paste("\n----------------------------------------------\n") )
}
```


# 3. 인덱싱(Indexing)

인덱싱은 원하는 자료에 접근해 원하는 자료처리를 하기위해 매우 많이 활용되는 함수이다. 
매우 중요하고, 본 수업에서도 자주 활용될 예정이다.

인덱싱은 타겟 행 또는 열에 접근해서 추출하거나, 타겟 행 또는 열에 속한 값을 수정하는데
주로 활용된다. 

우선 실습을 위해 위에서 배운 함수를 바탕으로 데이터 프레임을 하나 만들어보자.

```{r}
df <- data.frame(name = c("국어", "영어", "수학", "경제", "역사", "물리", "화학"), 
                    score = c(90, 80, 88, 90, 66, 72, 75),
                    grade = c("A", "B", "B", "A", "D", "C", "C"))
df
```

먼저, 과목명들만 추출해 보자. 과목명은 1열에 있으므로 1열만 추출한다.
```{r}
df[,1] # 1열을 가져와
df[1,]
```

그 다음은 score와 grade를 같이 추출해보자
```{r}
df_23 <- df[,1:3]
```

이렇게 표현해도 된다.
```{r}
df[,-2]
df[,c(1,3,5,7,13,15)]
```

3행 2열엔 무슨 값이 있는지 보자
```{r}
df[3,2]
```

꼭 숫자로 인덱싱하지 않아도 된다.
```{r}
df[,"name"]
```

```{r}
df[,c("score", "grade")]
```

특정 조건을 충족하는 행 또는 열을 추출할 수도 있다.

```{r}
df$grade


df[df$score>=90,]
```

참고로 인덱싱 괄호를 쓰지않고, 특정 데이터프레임의 특정변수를 가져오는 방법은 `$`를 쓰면 된다.

```{r}
df$name
```

```{r}
df$score
```

# 4. 패키지 설치 및 라이브러리 불러오기

이제 오픈소스인 R이 가장 강력한 이유 중 하나인 패키지 모듈을 설치하는 것부터 라이브러리를
불러오는 방법을 살펴보자.

일단 동일PC에서 한번 패키지를 설치하면, 그 다음부터 사용할때는 라이브러리를 불러오기만 해서
사용가능하다.

먼저 패키지를 설치하는 방법은 `install.pacakges("패키지명")` 이다.
자료처리에 가장 많이 쓰이는 패키지 3개를 설치해보자.

(참고로 R 내 패키지는 무수히 많으므로 필요한 패키지는 그때그때 찾아서 설치하면 된다.)

```{r}
install.packages("reshape2")
install.packages("dplyr")
```

이제 설치한 패키지를 사용하기 위해 현재의 작업환경으로 불러오는 작업을 한다.
주의할 점은 코딩을 해놓고 R 작업환경을 새로 시작했을때, 라이브러리로 다시 불러오지 않으면
돌아가지 않을 수 있으니 반드시 코딩에 앞서 사용할 모듈을 미리 라이브러리로 불러오도록 하자.

```{r}
library(reshape2)
library(dplyr)
```

# 5. 실제 데이터 다뤄보기 : IRIS data

이제 위에서 배운 간단한 문법들을 활용해 실제 데이터를 다뤄보자.
다뤄볼 데이터는 `iris`라는 data이며, 자료처리에서 정석책처럼 꼭 한번은
다뤄보게 될 data 이다.

`iris` 데이터는 붓꽃(Iris)의 3가지 종(Setosa, Versicolor, Virginica)에 대한 정보를 담고 있으며, 

## 5-1. 데이터 불러오기

R에서 엑셀 확장자`(.xls, .xlsx)`는 바로 불러올 수 없고, 별도의 패키지가 필요하므로 분석용으로
쓰이는 자료는 항상 `.csv`로 준비하자.

`csv`파일을 불러오는 방법은 다음과 같다.

```{r}
iris <- read.csv("./iris.csv")
```

만약, 현재의 작업디렉토리에 데이터가 있지 않고, 다른 곳에 있다면 해당 파일이 위치한 전체
디렉토리를 모두 넣어줘야 한다.

```{r}
iris <- read.csv("C:/BusinessAnalytics/data/iris.csv")
```

## 5-2. 데이터 살펴보기

`head()`라는 함수를 통해 해당 데이터가 가진 변수가 어떤 것들인지 살펴볼 수 있다.
```{r}
head(iris)
```

여기서 각 변수는 다음과 같은 의미를 지닌다.

```
> X : 구분번호
> Sepal.Length : 꽃받침의 길이
> Sepal.Width : 꽃받침의 너비
> Petal.Legnth : 꽃잎의 길이
> Petal.Width : 꽃잎의 너비
> Species : 붓꽃의 종
```

데이터의 각 변수의 특징을 살펴볼 때는 `summary()` 함수를 사용하면 된다. 
```{r}
summary(iris)
```


위에서 배운 내용을 하나씩 적용해보도록 하자.

### 변수 및 데이터타입 확인

`iris` 데이터는 데이터프레임(data frame)이다.
```{r}
class(iris)
```

각각의 변수는 어떤 타입일까?
꽃받침의 길이(Sepal.Length) 변수를 살펴보자.

```{r}
class(iris$Sepal.Length)
```

다음은 붓꽃의 종(Species)을 살펴보자.
붓꽃의 종(Species)는 문자형 변수인데 `character type`이 아니라 `factor type`이다.

즉, 문자형이지만 `factor type`으로 각각의 종(species)은 명목 상 구분의 의미를 지니고 있다.

```{r}
class(iris$Species)
```

데이터에 포함된 변수 및 변수타입을 한번에 보는 방법은 `str()`을 쓸 수 있다.
```{r}
str(iris)
```

### 인덱싱

붓꽃의 종이 Setosa인 자료만 따로 모아 `iris_setosa`라는 데이터프레임(data frame)을 만들어보자
```{r}
iris_setosa <- iris[iris$Species=="setosa",]
```

iris_setosa의 `species` 변수를 살펴보면, setosa만 50개 남아있는 것을 알 수 있다.
```{r}
summary(iris_setosa)
```

이번엔 꽃받침의 길이가 6이상인 자료만 모아보자.
```{r}
iris_sep_over6 <- iris[iris$Sepal.Length >= 6,]
```

새롭게 만든 자료를 살펴보면, `versicolor`가 24개, `virginica`가 43개 포함된 것을 알 수 있다.

`붓꽃(iris)`에 대한 사전지식이 없지만 데이터만 봐도 `setosa` < `versicolor` < `virginica`의 순으로 꽃받침의 길이가 클 것이라고 짐작할 수 있다.

```{r}
summary(iris_sep_over6)
```
